{"version":3,"sources":["../../src/persistence/subject-builder/CascadesSubjectBuilder.ts"],"names":[],"mappings":";;;AAAA,sCAAmC;AAGnC;;;GAGG;AACH;IAEI,wEAAwE;IACxE,cAAc;IACd,wEAAwE;IAExE,gCAAsB,WAAsB;QAAtB,gBAAW,GAAX,WAAW,CAAW;IAC5C,CAAC;IAED,wEAAwE;IACxE,iBAAiB;IACjB,wEAAwE;IAExE;;OAEG;IACH,sCAAK,GAAL,UAAM,OAAgB;QAAtB,iBAyCC;QAvCG,OAAO,CAAC,QAAQ;aACX,+BAA+B,CAAC,OAAO,CAAC,MAAO,EAAE,OAAO,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC,sDAAsD;aACnI,OAAO,CAAC,UAAC,EAAkD;gBAAlD,0BAAkD,EAAjD,gBAAQ,EAAE,sBAAc,EAAE,8BAAsB;YAEvD,0FAA0F;YAC1F,IAAI,cAAc,KAAK,SAAS;gBAC5B,cAAc,KAAK,IAAI;gBACvB,CAAC,CAAC,QAAQ,CAAC,eAAe,IAAI,CAAC,QAAQ,CAAC,eAAe,CAAC;gBACxD,OAAO;YAEX,0EAA0E;YAC1E,2FAA2F;YAC3F,IAAI,CAAC,CAAC,cAAc,YAAY,MAAM,CAAC;gBACnC,OAAO;YAEX,6FAA6F;YAC7F,IAAM,iCAAiC,GAAG,KAAI,CAAC,uBAAuB,CAAC,sBAAsB,CAAC,MAAM,EAAE,cAAc,CAAC,CAAC;YACtH,IAAI,iCAAiC,EAAE;gBACnC,IAAI,iCAAiC,CAAC,aAAa,KAAK,KAAK,EAAE,sCAAsC;oBACjG,iCAAiC,CAAC,aAAa,GAAG,QAAQ,CAAC,eAAe,KAAK,IAAI,CAAC;gBACxF,IAAI,iCAAiC,CAAC,YAAY,KAAK,KAAK,EAAE,mCAAmC;oBAC7F,iCAAiC,CAAC,YAAY,GAAG,QAAQ,CAAC,eAAe,KAAK,IAAI,CAAC;gBACvF,OAAO;aACV;YAED,2CAA2C;YAC3C,yFAAyF;YACzF,IAAM,qBAAqB,GAAG,IAAI,iBAAO,CAAC;gBACtC,QAAQ,EAAE,sBAAsB;gBAChC,aAAa,EAAE,OAAO;gBACtB,MAAM,EAAE,cAAc;gBACtB,aAAa,EAAE,QAAQ,CAAC,eAAe,KAAK,IAAI;gBAChD,YAAY,EAAE,QAAQ,CAAC,eAAe,KAAK,IAAI;aAClD,CAAC,CAAC;YACH,KAAI,CAAC,WAAW,CAAC,IAAI,CAAC,qBAAqB,CAAC,CAAC;YAE7C,kEAAkE;YAClE,KAAI,CAAC,KAAK,CAAC,qBAAqB,CAAC,CAAC;QACtC,CAAC,CAAC,CAAC;IACX,CAAC;IAED,wEAAwE;IACxE,oBAAoB;IACpB,wEAAwE;IAExE;;;OAGG;IACO,wDAAuB,GAAjC,UAAkC,YAA6B,EAAE,MAAqB;QAClF,OAAO,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,UAAA,OAAO;YAChC,IAAI,CAAC,OAAO,CAAC,MAAM;gBACf,OAAO,KAAK,CAAC;YAEjB,IAAI,OAAO,CAAC,MAAM,KAAK,MAAM;gBACzB,OAAO,IAAI,CAAC;YAEhB,OAAO,OAAO,CAAC,QAAQ,CAAC,MAAM,KAAK,YAAY,IAAI,OAAO,CAAC,QAAQ,CAAC,eAAe,CAAC,OAAO,CAAC,sBAAuB,EAAE,MAAM,CAAC,CAAC;QACjI,CAAC,CAAC,CAAC;IACP,CAAC;IAEL,6BAAC;AAAD,CA/EA,AA+EC,IAAA;AA/EY,wDAAsB","file":"CascadesSubjectBuilder.js","sourcesContent":["import {Subject} from \"../Subject\";\nimport {ObjectLiteral} from \"../../common/ObjectLiteral\";\n\n/**\n * Finds all cascade operations of the given subject and cascade operations of the found cascaded subjects,\n * e.g. builds a cascade tree and creates a subjects for them.\n */\nexport class CascadesSubjectBuilder {\n\n    // ---------------------------------------------------------------------\n    // Constructor\n    // ---------------------------------------------------------------------\n\n    constructor(protected allSubjects: Subject[]) {\n    }\n\n    // ---------------------------------------------------------------------\n    // Public Methods\n    // ---------------------------------------------------------------------\n\n    /**\n     * Builds a cascade subjects tree and pushes them in into the given array of subjects.\n     */\n    build(subject: Subject) {\n\n        subject.metadata\n            .extractRelationValuesFromEntity(subject.entity!, subject.metadata.relations) // todo: we can create EntityMetadata.cascadeRelations\n            .forEach(([relation, relationEntity, relationEntityMetadata]) => {\n\n                // we need only defined values and insert or update cascades of the relation should be set\n                if (relationEntity === undefined ||\n                    relationEntity === null ||\n                    (!relation.isCascadeInsert && !relation.isCascadeUpdate))\n                    return;\n\n                // if relation entity is just a relation id set (for example post.tag = 1)\n                // then we don't really need to check cascades since there is no object to insert or update\n                if (!(relationEntity instanceof Object))\n                    return;\n\n                // if we already has this entity in list of operated subjects then skip it to avoid recursion\n                const alreadyExistRelationEntitySubject = this.findByPersistEntityLike(relationEntityMetadata.target, relationEntity);\n                if (alreadyExistRelationEntitySubject) {\n                    if (alreadyExistRelationEntitySubject.canBeInserted === false) // if its not marked for insertion yet\n                        alreadyExistRelationEntitySubject.canBeInserted = relation.isCascadeInsert === true;\n                    if (alreadyExistRelationEntitySubject.canBeUpdated === false) // if its not marked for update yet\n                        alreadyExistRelationEntitySubject.canBeUpdated = relation.isCascadeUpdate === true;\n                    return;\n                }\n\n                // mark subject with what we can do with it\n                // and add to the array of subjects to load only if there is no same entity there already\n                const relationEntitySubject = new Subject({\n                    metadata: relationEntityMetadata,\n                    parentSubject: subject,\n                    entity: relationEntity,\n                    canBeInserted: relation.isCascadeInsert === true,\n                    canBeUpdated: relation.isCascadeUpdate === true\n                });\n                this.allSubjects.push(relationEntitySubject);\n\n                // go recursively and find other entities we need to insert/update\n                this.build(relationEntitySubject);\n            });\n    }\n\n    // ---------------------------------------------------------------------\n    // Protected Methods\n    // ---------------------------------------------------------------------\n\n    /**\n     * Finds subject where entity like given subject's entity.\n     * Comparision made by entity id.\n     */\n    protected findByPersistEntityLike(entityTarget: Function|string, entity: ObjectLiteral): Subject|undefined {\n        return this.allSubjects.find(subject => {\n            if (!subject.entity)\n                return false;\n\n            if (subject.entity === entity)\n                return true;\n\n            return subject.metadata.target === entityTarget && subject.metadata.compareEntities(subject.entityWithFulfilledIds!, entity);\n        });\n    }\n\n}"],"sourceRoot":"../.."}