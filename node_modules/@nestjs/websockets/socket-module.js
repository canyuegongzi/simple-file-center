"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const guards_consumer_1 = require("@nestjs/core/guards/guards-consumer");
const guards_context_creator_1 = require("@nestjs/core/guards/guards-context-creator");
const load_adapter_1 = require("@nestjs/core/helpers/load-adapter");
const interceptors_consumer_1 = require("@nestjs/core/interceptors/interceptors-consumer");
const interceptors_context_creator_1 = require("@nestjs/core/interceptors/interceptors-context-creator");
const pipes_consumer_1 = require("@nestjs/core/pipes/pipes-consumer");
const pipes_context_creator_1 = require("@nestjs/core/pipes/pipes-context-creator");
const iterare_1 = require("iterare");
const constants_1 = require("./constants");
const container_1 = require("./container");
const exception_filters_context_1 = require("./context/exception-filters-context");
const ws_context_creator_1 = require("./context/ws-context-creator");
const ws_proxy_1 = require("./context/ws-proxy");
const socket_server_provider_1 = require("./socket-server-provider");
const web_sockets_controller_1 = require("./web-sockets-controller");
class SocketModule {
    constructor() {
        this.socketsContainer = new container_1.SocketsContainer();
    }
    register(container, config, httpServer) {
        this.applicationConfig = config;
        this.httpServer = httpServer;
        const contextCreator = this.getContextCreator(container);
        const serverProvider = new socket_server_provider_1.SocketServerProvider(this.socketsContainer, config);
        this.webSocketsController = new web_sockets_controller_1.WebSocketsController(serverProvider, config, contextCreator);
        const modules = container.getModules();
        modules.forEach(({ providers }, moduleName) => this.combineAllGateways(providers, moduleName));
    }
    combineAllGateways(providers, moduleName) {
        [...providers.values()]
            .filter(wrapper => wrapper && !wrapper.isNotMetatype)
            .forEach(wrapper => this.combineGatewayAndServer(wrapper, moduleName));
    }
    combineGatewayAndServer(wrapper, moduleName) {
        const { instance, metatype } = wrapper;
        const metadataKeys = Reflect.getMetadataKeys(metatype);
        if (!metadataKeys.includes(constants_1.GATEWAY_METADATA)) {
            return;
        }
        if (!this.isAdapterInitialized) {
            this.initializeAdapter();
        }
        this.webSocketsController.mergeGatewayAndServer(instance, metatype, moduleName);
    }
    async close() {
        if (!this.applicationConfig) {
            return;
        }
        const adapter = this.applicationConfig.getIoAdapter();
        if (!adapter) {
            return;
        }
        const servers = this.socketsContainer.getAllServers();
        await Promise.all(iterare_1.default(servers.values())
            .filter(({ server }) => server)
            .map(async ({ server }) => adapter.close(server)));
        this.socketsContainer.clear();
    }
    initializeAdapter() {
        const adapter = this.applicationConfig.getIoAdapter();
        if (adapter) {
            this.isAdapterInitialized = true;
            return;
        }
        const { IoAdapter } = load_adapter_1.loadAdapter('@nestjs/platform-socket.io', 'WebSockets');
        const ioAdapter = new IoAdapter(this.httpServer);
        this.applicationConfig.setIoAdapter(ioAdapter);
        this.isAdapterInitialized = true;
    }
    getContextCreator(container) {
        return new ws_context_creator_1.WsContextCreator(new ws_proxy_1.WsProxy(), new exception_filters_context_1.ExceptionFiltersContext(container), new pipes_context_creator_1.PipesContextCreator(container), new pipes_consumer_1.PipesConsumer(), new guards_context_creator_1.GuardsContextCreator(container), new guards_consumer_1.GuardsConsumer(), new interceptors_context_creator_1.InterceptorsContextCreator(container), new interceptors_consumer_1.InterceptorsConsumer());
    }
}
exports.SocketModule = SocketModule;
